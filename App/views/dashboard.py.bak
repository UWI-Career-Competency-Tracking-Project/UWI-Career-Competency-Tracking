from flask import Blueprint, render_template, request, flash, redirect, url_for, jsonify, send_from_directory
from flask_login import login_required, current_user
from ..models.workshop import Workshop
from ..models.enrollment import Enrollment
from ..models.student import Student
from ..models.notification import Notification
from ..models.certificate_request import CertificateRequest
from .. import db
from datetime import datetime
from sqlalchemy import or_, func, distinct
import os
from werkzeug.utils import secure_filename
from ..models.user import User
from ..models.employer import Employer
from ..models.administrator import Administrator
from ..models.student_competency import StudentCompetency
from ..models.competency import Competency
from ..controllers import certificate_controller
from ..controllers import notification_controller
from ..models.job_roles import JobRole
from ..models.job_competency import JobCompetency
import io
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from PyPDF2 import PdfReader, PdfWriter
from dateutil.relativedelta import relativedelta
from dateutil.parser import parse
from ..models.certificate import Certificate

dashboard_views = Blueprint('dashboard_views', __name__, template_folder='../templates')

UPLOAD_FOLDER = 'App/static/workshop_images'
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Helper function to format timestamps as "time ago" strings
def format_time_ago(timestamp):
    """Format a timestamp as a "time ago" string (e.g., "2 hours ago")."""
    now = datetime.now()
    
    if isinstance(timestamp, str):
        try:
            timestamp = parse(timestamp)
        except:
            return "Unknown time"
    
    diff = now - timestamp
    seconds = diff.total_seconds()
    
    if seconds < 60:
        return "just now"
    elif seconds < 3600:
        minutes = int(seconds // 60)
        return f"{minutes} minute{'s' if minutes > 1 else ''} ago"
    elif seconds < 86400:
        hours = int(seconds // 3600)
        return f"{hours} hour{'s' if hours > 1 else ''} ago"
    elif seconds < 2592000:  # 30 days
        days = int(seconds // 86400)
        return f"{days} day{'s' if days > 1 else ''} ago"
    elif seconds < 31536000:  # 365 days
        months = int(seconds // 2592000)
        return f"{months} month{'s' if months > 1 else ''} ago"
    else:
        years = int(seconds // 31536000)
        return f"{years} year{'s' if years > 1 else ''} ago"

@dashboard_views.route('/student-dashboard')
@login_required
def student_dashboard():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    return render_template('Html/studentdashboard.html', user=current_user)

@dashboard_views.route('/admin-dashboard')
@login_required
def admin_dashboard():
    if current_user.user_type != 'admin':
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        # Get real statistics for the dashboard
        # 1. Count active workshops
        workshop_count = Workshop.query.count()
        
        # 2. Count enrolled students
        student_count = Student.query.count()
        
        # 3. Count awarded badges
        try:
            # Count StudentCompetency records with rank > 0
            badge_count = db.session.query(func.count(distinct(StudentCompetency.id))).filter(
                StudentCompetency.rank > 0
            ).scalar() or 0
            
            # Alternative calculation if the above doesn't match real badge count
            if badge_count == 0:
                # Count from the Student.competencies JSON field
                for student in Student.query.all():
                    if student.competencies:
                        for comp_name, comp_data in student.competencies.items():
                            if comp_data.get('rank', 0) > 0:
                                badge_count += 1
        except Exception as e:
            badge_count = 0
        
        # 4. Count issued certificates 
        try:
            # Try to count from Certificate model
            certificate_count = db.session.query(func.count(distinct(Certificate.id))).scalar() or 0
            
            # If Certificate model count is 0, count from Student's competencies
            if certificate_count == 0:
                for student in Student.query.all():
                    if student.competencies:
                        for comp_name, comp_data in student.competencies.items():
                            if comp_data.get('certificate_status') == 'approved':
                                certificate_count += 1
        except Exception as e:
            certificate_count = 0
        
        # Get workshop trends data (last 12 months)
        months = []
        workshop_creation_data = []
        workshop_attendance_data = []
        
        current_date = datetime.now()
        for i in range(11, -1, -1):
            # Calculate date for this data point (going back i months)
            target_date = current_date - relativedelta(months=i)
            month_name = target_date.strftime('%b')
            months.append(month_name)
            
            # Get workshops created in this month
            month_start = datetime(target_date.year, target_date.month, 1)
            if target_date.month == 12:
                month_end = datetime(target_date.year + 1, 1, 1) - relativedelta(days=1)
            else:
                month_end = datetime(target_date.year, target_date.month + 1, 1) - relativedelta(days=1)
                
            # Check if Workshop has created_at field
            has_created_at = hasattr(Workshop, 'created_at')
            if has_created_at:
                try:
                    created_count = Workshop.query.filter(
                        Workshop.created_at.between(month_start, month_end)
                    ).count()
                except Exception:
                    created_count = 0
            else:
                # If created_at doesn't exist, use a default value
                created_count = 0
            workshop_creation_data.append(created_count)
            
            # Get total enrollments in this month
            has_enrollment_date = hasattr(Enrollment, 'enrollment_date')
            if has_enrollment_date:
                try:
                    enrollment_count = db.session.query(func.count(Enrollment.id)).filter(
                        Enrollment.enrollment_date.between(month_start, month_end)
                    ).scalar() or 0
                except Exception:
                    enrollment_count = 0
            else:
                # If enrollment_date doesn't exist, use a default value
                enrollment_count = 0
            workshop_attendance_data.append(enrollment_count)
        
        # Get competency distribution data
        competency_data = []
        competency_labels = []
        
        # Get all unique competencies across workshops
        all_competencies = set()
        for workshop in Workshop.query.all():
            if hasattr(workshop, 'competencies') and workshop.competencies:
                all_competencies.update(workshop.competencies)
        
        # Count workshops for each competency
        for competency in all_competencies:
            if competency:  # Skip empty competencies
                count = 0
                for workshop in Workshop.query.all():
                    if hasattr(workshop, 'competencies') and workshop.competencies and competency in workshop.competencies:
                        count += 1
                if count > 0:
                    competency_labels.append(competency)
                    competency_data.append(count)
        
        # If no competency data, add a placeholder
        if not competency_data:
            competency_labels = ['No Competencies']
            competency_data = [1]
        
        # Get recent activities
        recent_activities = []
        
        # 1. Recent workshops
        has_created_at = hasattr(Workshop, 'created_at')
        if has_created_at:
            try:
                recent_workshops = Workshop.query.order_by(Workshop.created_at.desc()).limit(3).all()
            except Exception:
                recent_workshops = Workshop.query.limit(3).all()
        else:
            recent_workshops = Workshop.query.limit(3).all()
        
        for workshop in recent_workshops:
            created_at = getattr(workshop, 'created_at', datetime.now())
            recent_activities.append({
                'type': 'workshop',
                'icon': 'fas fa-chalkboard-teacher',
                'title': f'New Workshop: {workshop.workshopName}',
                'time': format_time_ago(created_at)
            })
        
        # 2. Recent badges and certificates from student competencies
        recent_comp_activities = []
        
        for student in Student.query.all():
            if student.competencies:
                for comp_name, comp_data in student.competencies.items():
                    # Check for badges with rank > 0
                    if comp_data.get('rank', 0) > 0:
                        updated_at_str = comp_data.get('updated_at')
                        if updated_at_str:
                            try:
                                updated_at = datetime.fromisoformat(updated_at_str.replace('Z', '+00:00'))
                                student_name = f"{student.first_name} {student.last_name}"
                                rank_name = ['Beginner', 'Intermediate', 'Advanced'][comp_data.get('rank', 1) - 1]
                                
                                recent_comp_activities.append({
                                    'type': 'badge',
                                    'icon': 'fas fa-award',
                                    'title': f'{student_name} earned {comp_name} Badge ({rank_name})',
                                    'time': format_time_ago(updated_at),
                                    'date': updated_at  # For sorting
                                })
                            except (ValueError, TypeError):
                                pass
                    
                    # Check for approved certificates
                    if comp_data.get('certificate_status') == 'approved':
                        cert_date_str = comp_data.get('certificate_date')
                        if cert_date_str:
                            try:
                                try:
                                    cert_date = datetime.strptime(cert_date_str, '%Y-%m-%d')
                                except ValueError:
                                    cert_date = datetime.fromisoformat(cert_date_str.replace('Z', '+00:00'))
                                
                                student_name = f"{student.first_name} {student.last_name}"
                                
                                recent_comp_activities.append({
                                    'type': 'certificate',
                                    'icon': 'fas fa-certificate',
                                    'title': f'Certificate issued to {student_name} for {comp_name}',
                                    'time': format_time_ago(cert_date),
                                    'date': cert_date  # For sorting
                                })
                            except (ValueError, TypeError):
                                pass
        
        # Sort by date (newest first) and take top 3
        recent_comp_activities.sort(key=lambda x: x['date'], reverse=True)
        recent_comp_activities = recent_comp_activities[:3]
        
        # Remove date field used for sorting
        for activity in recent_comp_activities:
            activity.pop('date', None)
        
        # Add to recent activities
        recent_activities.extend(recent_comp_activities)
        
        # Sort activities by time (most recent first)
        try:
            recent_activities.sort(key=lambda x: x['time'], reverse=True)
        except Exception:
            # If sorting fails, just take the first 5
            pass
        recent_activities = recent_activities[:5]  # Limit to 5 items
        
        # Prepare data for student progress chart (last 12 months)
        progress_labels = months.copy()
        badges_earned_data = []
        certificates_issued_data = []
        
        for i in range(11, -1, -1):
            target_date = current_date - relativedelta(months=i)
            month_start = datetime(target_date.year, target_date.month, 1)
            if target_date.month == 12:
                month_end = datetime(target_date.year + 1, 1, 1) - relativedelta(days=1)
            else:
                month_end = datetime(target_date.year, target_date.month + 1, 1) - relativedelta(days=1)
            
            # Count badges earned in this month
            badges_count = 0
            # Count from student competencies updated in this month
            for student in Student.query.all():
                if student.competencies:
                    for comp_name, comp_data in student.competencies.items():
                        comp_date_str = comp_data.get('updated_at')
                        if comp_date_str and comp_data.get('rank', 0) > 0:
                            try:
                                # Parse the ISO date string
                                comp_date = datetime.fromisoformat(comp_date_str.replace('Z', '+00:00'))
                                # Check if it's in the current month
                                if month_start <= comp_date <= month_end:
                                    badges_count += 1
                            except (ValueError, TypeError):
                                # Skip invalid dates
                                pass
            badges_earned_data.append(badges_count)
            
            # Count certificates issued in this month
            certs_count = 0
            # Count from student competencies with certificate approval in this month
            for student in Student.query.all():
                if student.competencies:
                    for comp_name, comp_data in student.competencies.items():
                        cert_date_str = comp_data.get('certificate_date')
                        if cert_date_str and comp_data.get('certificate_status') == 'approved':
                            try:
                                # Try parsing the date in different formats
                                try:
                                    cert_date = datetime.strptime(cert_date_str, '%Y-%m-%d')
                                except ValueError:
                                    cert_date = datetime.fromisoformat(cert_date_str.replace('Z', '+00:00'))
                                
                                # Check if it's in the current month
                                if month_start <= cert_date <= month_end:
                                    certs_count += 1
                            except (ValueError, TypeError):
                                # Skip invalid dates
                                pass
            certificates_issued_data.append(certs_count)
        
        # Pass all dashboard data to the template
        return render_template(
            'Html/admindashboard.html', 
            user=current_user,
            workshop_count=workshop_count,
            student_count=student_count,
            badge_count=badge_count,
            certificate_count=certificate_count,
            recent_activities=recent_activities,
            # Chart data as JSON
            workshop_trends_labels=months,
            workshop_creation_data=workshop_creation_data,
            workshop_attendance_data=workshop_attendance_data,
            competency_labels=competency_labels,
            competency_data=competency_data,
            progress_labels=progress_labels,
            badges_earned_data=badges_earned_data,
            certificates_issued_data=certificates_issued_data
        )
    except Exception as e:
        import traceback
        traceback.print_exc()
        flash(f'Error loading dashboard data: {str(e)}', 'error')
        return render_template(
            'Html/admindashboard.html',
            user=current_user,
            workshop_count=0,
            student_count=0,
            badge_count=0,
            certificate_count=0,
            recent_activities=[],
            workshop_trends_labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            workshop_creation_data=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            workshop_attendance_data=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            competency_labels=['No Data'],
            competency_data=[100],
            progress_labels=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            badges_earned_data=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            certificates_issued_data=[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        )

@dashboard_views.route('/employer-dashboard')
@login_required
def employer_dashboard():
    if current_user.user_type != 'employer':
        flash('Access denied. Employers only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    return render_template('Html/employerdashboard.html', user=current_user)

@dashboard_views.route('/dashboard')
@login_required
def dashboard():
    # Redirect to appropriate dashboard based on user type
    if current_user.user_type == 'student':
        return redirect(url_for('dashboard_views.student_dashboard'))
    elif current_user.user_type == 'admin':
        return redirect(url_for('dashboard_views.admin_dashboard'))
    elif current_user.user_type == 'employer':
        return redirect(url_for('dashboard_views.employer_dashboard'))
    
    return render_template('Html/dashboard.html', user=current_user)

@dashboard_views.route('/workshops')
@login_required
def workshops():
    search_query = request.args.get('search', '').strip().lower()
    print("Accessing workshops route with search query:", search_query)
    
    try:
        all_workshops = Workshop.query.all()
        print(f"Retrieved {len(all_workshops)} workshops from database")
        
        for workshop in all_workshops:
            if workshop._competencies is None:
                workshop._competencies = []
                db.session.add(workshop)
        
        # Filter out workshops the student is already enrolled in
        if current_user.user_type == 'student':
            enrolled_workshop_ids = [
                enrollment.workshop_id for enrollment in 
                Enrollment.query.filter_by(student_id=current_user.id).all()
            ]
            all_workshops = [
                workshop for workshop in all_workshops 
                if workshop.id not in enrolled_workshop_ids
            ]
            print(f"Filtered out enrolled workshops, {len(all_workshops)} remaining")
        
        if search_query:
            filtered_workshops = []
            for workshop in all_workshops:
                workshop_data = [
                    workshop.workshopName.lower(),
                    (workshop.workshopDescription or '').lower(),
                    (workshop.instructor or '').lower(),
                    (workshop.location or '').lower()
                ]
                workshop_competencies = [comp.lower() for comp in workshop.competencies]
                
                if any(search_query in data for data in workshop_data) or \
                   any(search_query in comp for comp in workshop_competencies):
                    filtered_workshops.append(workshop)
            all_workshops = filtered_workshops
        
        print(f"Returning {len(all_workshops)} workshops after filtering")
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return render_template('Html/workshops_list.html', 
                                workshops=all_workshops,
                                search_query=search_query)
        
        return render_template('Html/studentsAvailableWorkshops.html', 
                             workshops=all_workshops,
                             search_query=search_query,
                             user=current_user)
                             
    except Exception as e:
        print(f"Error in workshops route: {str(e)}")
        import traceback
        print("Full traceback:")
        traceback.print_exc()
        db.session.rollback()
        flash('Error loading workshops. Please try again.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

@dashboard_views.route('/admin-workshop-creation/', methods=['GET', 'POST'])
@login_required
def admin_workshop_creation():
    if current_user.user_type != 'admin':
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    if request.method == 'POST':
        try:
            image_path = None
            if 'workshop_image' in request.files:
                file = request.files['workshop_image']
                if file and file.filename != '':
                    if allowed_file(file.filename):
                        if not os.path.exists(UPLOAD_FOLDER):
                            os.makedirs(UPLOAD_FOLDER)
                        
                        filename = secure_filename(file.filename)
                        file_path = os.path.join(UPLOAD_FOLDER, filename)
                        file.save(file_path)
                        image_path = f'workshop_images/{filename}'
                    else:
                        flash('Invalid file type. Please upload an image file.', 'error')
                        return redirect(request.url)

            # Get competencies from multi-select dropdown - try different possible name formats
            competencies = []
            if 'competencies[]' in request.form:
                competencies = request.form.getlist('competencies[]')
            elif 'competencies' in request.form:
                competencies = request.form.getlist('competencies')
            else:
                # Check if we have a single competency value
                for key in request.form:
                    if key.startswith('competencies'):
                        competencies = [request.form[key]]
                        break
            
            # Check if list of competencies was provided as a single comma-separated string
            if len(competencies) == 1 and ',' in competencies[0]:
                competencies = [comp.strip() for comp in competencies[0].split(',') if comp.strip()]
                
            new_workshop = Workshop(
                workshopID=request.form.get('id'),
                workshopName=request.form.get('name'),
                workshopDescription=request.form.get('description'),
                workshopDate=datetime.strptime(request.form.get('date'), '%Y-%m-%d').date(),
                workshopTime=request.form.get('time'),
                instructor=request.form.get('instructor'),
                location=request.form.get('location'),
                image_path=image_path
            )
            
            if competencies:
                new_workshop.add_competencies(competencies)
            
            db.session.add(new_workshop)
            db.session.commit()
            
            # Send notifications to students
            student_ids = [student.id for student in Student.query.all()]
            workshop_link = url_for('dashboard_views.workshops', _external=True)
            notification_controller.create_workshop_notification(
                student_ids=student_ids,
                workshop_name=new_workshop.workshopName,
                action_type='created',
                link=workshop_link
            )
            
            flash('Workshop created successfully!', 'success')
            return redirect(url_for('dashboard_views.workshops'))
            
        except Exception as e:
            db.session.rollback()
            flash(f'Error creating workshop: {str(e)}', 'error')
            return redirect(url_for('dashboard_views.admin_workshop_creation'))

    return render_template('Html/adminWorkshopCreation.html')

@dashboard_views.route('/enroll-workshop/<workshop_id>')
@login_required
def enroll_workshop(workshop_id):
    if not isinstance(current_user, Student):
        flash('Only students can enroll in workshops.', 'error')
        return redirect(url_for('dashboard_views.workshops'))
    
    try:
        workshop = Workshop.query.get(workshop_id)
        if not workshop:
            flash('Workshop not found.', 'error')
            return redirect(url_for('dashboard_views.workshops'))
        
        print(f"Found workshop: {workshop.workshopName}")
        print(f"Workshop competencies: {workshop.competencies}")
        
        existing_enrollment = Enrollment.query.filter_by(
            student_id=current_user.id,
            workshop_id=workshop_id
        ).first()
        
        if existing_enrollment:
            flash('You are already enrolled in this workshop.', 'info')
            return redirect(url_for('dashboard_views.workshops'))
        
        enrollment = Enrollment(
            student_id=current_user.id,
            workshop_id=workshop_id
        )
        db.session.add(enrollment)
        db.session.flush()  
        
        print("Created enrollment, adding competencies...")
        
        enrollment.add_workshop_competencies()
        
        student = Student.query.get(current_user.id)
        print(f"Student competencies after enrollment: {student.competencies}")
        
        db.session.commit()
        flash('Successfully enrolled in workshop!', 'success')
        
    except Exception as e:
        db.session.rollback()
        print(f"Error enrolling in workshop: {e}")
        import traceback
        print("Full traceback:")
        traceback.print_exc()
        flash('An error occurred while enrolling in the workshop.', 'error')
    
    return redirect(url_for('dashboard_views.workshops'))

@dashboard_views.route('/competencies')
@login_required
def competencies():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
        
    try:
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.dashboard'))
        
        # Format competencies data for display
        for comp_name, comp_data in student.competencies.items():
            # Ensure the certificate_status field exists
            if 'certificate_status' not in comp_data:
                student.competencies[comp_name]['certificate_status'] = None
            
            # Convert empty string to None for consistency
            if comp_data.get('certificate_status') == '':
                student.competencies[comp_name]['certificate_status'] = None
        
        return render_template('Html/competencies.html', user=student)
        
    except Exception as e:
        print(f"Error loading competencies: {e}")
        import traceback
        traceback.print_exc()
        flash('Error loading competencies.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

@dashboard_views.route('/my-workshops')
@login_required
def my_workshops():
    if current_user.user_type != 'student':
        flash('Only students can view their workshops.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
        
    try:
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.dashboard'))
        
        enrolled_workshops = Workshop.query.join(Enrollment).filter(
            Enrollment.student_id == student.id
        ).all()
        
        print(f"Found {len(enrolled_workshops)} enrolled workshops for student {student.username}")
        
        return render_template('Html/myWorkshops.html', 
                             workshops=enrolled_workshops,
                             user=student)
                             
    except Exception as e:
        print(f"Error fetching workshops: {e}")
        db.session.rollback()
        flash('Error loading workshops.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

@dashboard_views.route('/manage-workshops')
@login_required
def manage_workshops():
    print("Accessing manage_workshops route") 
    print(f"Current user type: {current_user.user_type}") 
    
    if current_user.user_type != 'admin':
        print(f"Access denied for user: {current_user.username}, type: {current_user.user_type}") 
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    workshops = Workshop.query.all()
    print(f"Found {len(workshops)} workshops") 
    return render_template('Html/manageWorkshops.html', workshops=workshops)

@dashboard_views.route('/edit-workshop/<workshop_id>', methods=['GET', 'POST'])
@login_required
def edit_workshop(workshop_id):
    if current_user.user_type != 'admin':
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
        
    workshop = Workshop.query.get_or_404(workshop_id)
    
    if request.method == 'POST':
        try:
            workshop.workshopName = request.form['name']
            workshop.workshopDescription = request.form['description']
            workshop.workshopDate = datetime.strptime(request.form['date'], '%Y-%m-%d').date()
            workshop.workshopTime = request.form['time']
            workshop.instructor = request.form['instructor']
            workshop.location = request.form['location']
            
            if 'workshop_image' in request.files:
                file = request.files['workshop_image']
                if file and file.filename != '':
                    if allowed_file(file.filename):
                        if not os.path.exists(UPLOAD_FOLDER):
                            os.makedirs(UPLOAD_FOLDER)
                        
                        filename = secure_filename(file.filename)
                        file_path = os.path.join(UPLOAD_FOLDER, filename)
                        file.save(file_path)
                        workshop.image_path = f'workshop_images/{filename}'
                    else:
                        flash('Invalid file type. Please upload an image file.', 'error')
                        return redirect(request.url)
            
            competencies = [comp.strip() for comp in request.form.get('competencies', '').split(',') if comp.strip()]
            if competencies:
                workshop.add_competencies(competencies)
            
            db.session.commit()
            
            # Always send notifications to enrolled students
            enrolled_students = [enrollment.student_id for enrollment in workshop.enrollments]
            if enrolled_students:
                workshop_link = url_for('dashboard_views.workshops', _external=True)
                notification_controller.create_workshop_notification(
                    student_ids=enrolled_students,
                    workshop_name=workshop.workshopName,
                    action_type='updated',
                    link=workshop_link
                )
            
            flash('Workshop updated successfully!', 'success')
            return redirect(url_for('dashboard_views.manage_workshops'))
            
        except Exception as e:
            db.session.rollback()
            print(f"Error updating workshop: {e}")
            flash(f'Error updating workshop: {str(e)}', 'error')
            
    return render_template('Html/editWorkshop.html', workshop=workshop)

@dashboard_views.route('/delete-workshop/<workshop_id>', methods=['DELETE'])
@login_required
def delete_workshop(workshop_id):
    if current_user.user_type != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
        
    workshop = Workshop.query.get_or_404(workshop_id)
    
    if workshop.enrollments:
        return jsonify({'error': 'Cannot delete workshop with enrolled students'}), 400
        
    try:
        db.session.delete(workshop)
        db.session.commit()
        return jsonify({'message': 'Workshop deleted successfully'}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@dashboard_views.route('/admin-badges', methods=['GET', 'POST'])
@login_required
def admin_badges():
    if current_user.user_type != 'admin':
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    search_query = request.args.get('search', '')
    
    students_query = Student.query
    
    if search_query:
        students_query = students_query.filter(
            or_(
                Student.first_name.ilike(f'%{search_query}%'),
                Student.last_name.ilike(f'%{search_query}%'),
                Student.username.ilike(f'%{search_query}%')
            )
        )
    
    students = students_query.all()
    
    student_competencies = []
    for student in students:
        if student.competencies:
            for comp_name in student.competencies:
                student_competencies.append({
                    'student': student,
                    'competency': comp_name,
                    'data': student.competencies[comp_name]
                })
    
    if request.method == 'POST':
        try:
            student_id = request.form.get('student_id')
            competency = request.form.get('competency')
            rank = request.form.get('rank')
            feedback = request.form.get('feedback', '')
            
            print(f"Received update request - Student ID: {student_id}, Competency: {competency}, Rank: {rank}, Feedback: {feedback}")
            
            if not rank:
                flash('Please select a rank', 'error')
                return redirect(url_for('dashboard_views.admin_badges'))
            
            student = Student.query.get(student_id)
            if student:
                rank = int(rank)
                if rank not in [1, 2, 3]:
                    flash('Invalid rank selected', 'error')
                    return redirect(url_for('dashboard_views.admin_badges'))
                
                print(f"Updating student competency - Before update: {student.competencies.get(competency)}")
                student.update_competency_rank(competency, rank, feedback)
                print(f"After update: {student.competencies.get(competency)}")
                
                # Send notification to student about badge update
                badge_link = url_for('dashboard_views.earned_badges', _external=True)
                notification_controller.create_badge_notification(
                    student_id=student_id,
                    competency_name=competency,
                    rank=rank,
                    link=badge_link
                )
                
                db.session.commit()
                flash('Student competency updated successfully!', 'success')
            else:
                flash('Student not found', 'error')
            
        except Exception as e:
            print(f"Error updating competency: {e}")
            db.session.rollback()
            flash('Error updating student competency.', 'error')
    
    return render_template('Html/adminbadges.html', 
                         student_competencies=student_competencies,
                         search_query=search_query)

@dashboard_views.route('/unenroll-workshop/<workshop_id>', methods=['POST'])
@login_required
def unenroll_workshop(workshop_id):
    if not isinstance(current_user, Student):
        return jsonify({'error': 'Only students can unenroll from workshops.'}), 403
    
    try:
        student = Student.query.get(current_user.id)
        if not student:
            return jsonify({'error': 'Student not found.'}), 404

        enrollment = Enrollment.query.filter_by(
            student_id=student.id,
            workshop_id=workshop_id
        ).first()
        
        if not enrollment:
            return jsonify({'error': 'You are not enrolled in this workshop.'}), 404
        
        workshop = Workshop.query.get(workshop_id)
        
        if workshop and workshop.competencies:
            other_workshops = Workshop.query.join(Enrollment).filter(
                Enrollment.student_id == student.id,
                Workshop.id != workshop_id
            ).all()
            
            for comp_name in workshop.competencies:
                competency_in_other_workshop = False
                for other_workshop in other_workshops:
                    if comp_name in other_workshop.competencies:
                        competency_in_other_workshop = True
                        break
                
                if not competency_in_other_workshop:
                    competency = Competency.query.filter_by(name=comp_name).first()
                    if competency:
                        StudentCompetency.query.filter_by(
                            student_id=student.id,
                            competency_id=competency.id
                        ).delete()
        
        db.session.delete(enrollment)
        db.session.commit()
        
        return jsonify({'message': 'Successfully unenrolled from workshop.'}), 200
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@dashboard_views.route('/request-certificate', methods=['POST'])
@login_required
def request_certificate():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        competency = request.form.get('competency')
        if not competency:
            flash('Invalid request.', 'error')
            return redirect(url_for('dashboard_views.competencies'))
        
        student = Student.query.get(current_user.id)
        if not student:
            flash('Student not found.', 'error')
            return redirect(url_for('dashboard_views.competencies'))
        
        if competency not in student.competencies:
            flash('Competency not found.', 'error')
            return redirect(url_for('dashboard_views.competencies'))
            
        comp_data = student.competencies[competency]
        if comp_data.get('rank') != 3:
            flash('Certificate can only be requested for Advanced rank competencies.', 'error')
            return redirect(url_for('dashboard_views.competencies'))
        
        success, message = certificate_controller.request_certificate(current_user.id, competency)
        
        if success:
            student.update_competency_certificate_status(competency, 'pending')
            flash('Certificate request submitted successfully.', 'success')
        else:
            flash(message, 'error')
            
        return redirect(url_for('dashboard_views.competencies'))
        
    except Exception as e:
        print(f"Error in request_certificate: {str(e)}")
        import traceback
        traceback.print_exc()
        flash('An error occurred while processing your request.', 'error')
        return redirect(url_for('dashboard_views.competencies'))

@dashboard_views.route('/validate-certificates')
@login_required
def validate_certificates():
    if current_user.user_type != 'admin':
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    pending_requests = certificate_controller.get_pending_requests()
    return render_template('Html/adminValidatecomp.html', pending_requests=pending_requests)

@dashboard_views.route('/process-certificate-request/<int:request_id>', methods=['POST'])
@login_required
def process_certificate_request(request_id):
    if current_user.user_type != 'admin':
        flash('Access denied. Administrators only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    action = request.form.get('action')
    if action not in ['approve', 'deny']:
        flash('Invalid action.', 'error')
        return redirect(url_for('dashboard_views.validate_certificates'))
    
    success, message = certificate_controller.process_request(request_id, action)
    
    if success:
        # Get certificate request details to send notification
        cert_request = CertificateRequest.query.get(request_id)
        if cert_request:
            certificate_link = url_for('dashboard_views.earned_badges', _external=True)
            notification_controller.create_certificate_notification(
                student_id=cert_request.student_id,
                competency_name=cert_request.competency,
                status='approved' if action == 'approve' else 'rejected',
                link=certificate_link
            )
    
    flash(message, 'success' if success else 'error')
    return redirect(url_for('dashboard_views.validate_certificates'))

@dashboard_views.route('/view-certificate/<competency>')
@login_required
def view_certificate(competency):
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    certificate_data = certificate_controller.get_certificate_data(current_user.id, competency)
    if not certificate_data:
        flash('Certificate not found.', 'error')
        return redirect(url_for('dashboard_views.competencies'))
    
    # Add user to certificate_data
    certificate_data['user'] = current_user
    
    return render_template('Html/studentCertificate.html', **certificate_data)

@dashboard_views.route('/earned-badges')
@login_required
def earned_badges():
    if current_user.user_type != 'student':
        flash('Only students can view their badges and certificates.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
        
    try:
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.dashboard'))
            
        earned_competencies = []
        if student.competencies:
            for comp_name, comp_data in student.competencies.items():
                rank = comp_data.get('rank', 0)
                certificate_status = comp_data.get('certificate_status', None)
                feedback = comp_data.get('feedback', '')
                
                if rank > 0:  
                    earned_competencies.append({
                        'name': comp_name,
                        'rank': rank,
                        'rank_name': ['Beginner', 'Intermediate', 'Advanced'][rank-1],
                        'certificate_status': certificate_status,
                        'feedback': feedback
                    })
        
        return render_template('Html/earnedBadges.html', 
                             user=student,
                             earned_competencies=earned_competencies)
                             
    except Exception as e:
        print(f"Error loading badges: {e}")
        flash('Error loading badges and certificates.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

@dashboard_views.route('/search-candidates')
@login_required
def search_candidates():
    print(f"Current user type: {current_user.user_type}")  
    if not current_user.is_authenticated or current_user.user_type != 'employer':
        flash('Access Denied. This page is only accessible to employers.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        competency_filter = request.args.get('competency', '').strip().lower()
        rank_filter = request.args.get('rank', '').strip()
        
        # Get all students
        students = Student.query.all()
        filtered_students = []
        
        for student in students:
            if student.competencies:  
                student_data = {
                    'id': student.id,
                    'first_name': student.first_name,
                    'last_name': student.last_name,
                    'email': student.email,
                    'competencies': []
                }
                
                # Process each competency
                for comp_name, comp_data in student.competencies.items():
                    rank = comp_data.get('rank', 0)
                    if rank > 0: 
                        rank_name = ['Beginner', 'Intermediate', 'Advanced'][rank-1]
                        
                        if rank_filter and str(rank) != rank_filter:
                            continue
                            
                        student_data['competencies'].append({
                            'name': comp_name,
                            'rank': rank,
                            'rank_name': rank_name
                        })
                
                if student_data['competencies'] and (
                    not competency_filter or 
                    any(competency_filter in comp['name'].lower() for comp in student_data['competencies'])
                ):
                    filtered_students.append(student_data)
        
        return render_template('Html/employerSearch.html', 
                             students=filtered_students,
                             search_query=competency_filter,
                             rank_filter=rank_filter)
                             
    except Exception as e:
        print(f"Error in candidate search: {e}")
        import traceback
        traceback.print_exc()
        flash('Error loading candidates.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

def create_sample_jobs():
    """Create sample jobs if none exist"""
    if JobRole.query.count() == 0:
        jobs = [
            {
                'title': 'Software Developer',
                'description': 'Design and develop software applications using modern technologies.',
                'required_rank': 2,  # Intermediate
                'competencies': [
                    ('Programming', 2),
                    ('Problem Solving', 2),
                    ('Team Work', 1)
                ]
            },
            {
                'title': 'Data Analyst',
                'description': 'Analyze complex data sets to identify trends and patterns.',
                'required_rank': 2,
                'competencies': [
                    ('Data Analysis', 2),
                    ('Problem Solving', 2),
                    ('Communication', 1)
                ]
            },
            {
                'title': 'Project Manager',
                'description': 'Lead and coordinate software development projects.',
                'required_rank': 3,  # Advanced
                'competencies': [
                    ('Leadership', 3),
                    ('Communication', 2),
                    ('Team Work', 2)
                ]
            },
            {
                'title': 'UI/UX Designer',
                'description': 'Create intuitive and visually appealing user interfaces for web and mobile applications.',
                'required_rank': 2,
                'competencies': [
                    ('Design Thinking', 2),
                    ('Communication', 2),
                    ('Creativity', 2)
                ]
            },
            {
                'title': 'DevOps Engineer',
                'description': 'Implement and maintain CI/CD pipelines and cloud infrastructure.',
                'required_rank': 3,
                'competencies': [
                    ('Cloud Computing', 3),
                    ('Problem Solving', 2),
                    ('System Administration', 2)
                ]
            },
            {
                'title': 'Business Analyst',
                'description': 'Bridge the gap between business needs and technical solutions.',
                'required_rank': 2,
                'competencies': [
                    ('Business Analysis', 2),
                    ('Communication', 2),
                    ('Problem Solving', 2)
                ]
            },
            {
                'title': 'Quality Assurance Engineer',
                'description': 'Ensure software quality through comprehensive testing and automation.',
                'required_rank': 2,
                'competencies': [
                    ('Testing', 2),
                    ('Attention to Detail', 2),
                    ('Problem Solving', 1)
                ]
            },
            {
                'title': 'Database Administrator',
                'description': 'Manage and optimize database systems and ensure data security.',
                'required_rank': 3,
                'competencies': [
                    ('Database Management', 3),
                    ('Security', 2),
                    ('Problem Solving', 2)
                ]
            },
            {
                'title': 'Technical Writer',
                'description': 'Create clear and comprehensive technical documentation and user guides.',
                'required_rank': 2,
                'competencies': [
                    ('Technical Writing', 2),
                    ('Communication', 3),
                    ('Documentation', 2)
                ]
            },
            {
                'title': 'Cybersecurity Analyst',
                'description': 'Protect systems and networks from security threats and vulnerabilities.',
                'required_rank': 3,
                'competencies': [
                    ('Security', 3),
                    ('Problem Solving', 2),
                    ('Risk Assessment', 2)
                ]
            }
        ]

        try:
            for job in jobs:
                new_job = JobRole(
                    jobTitle=job['title'],
                    jobDescription=job['description'],
                    requiredRank=job['required_rank']
                )
                db.session.add(new_job)
                db.session.flush()  

                for comp_name, rank in job['competencies']:
                    comp = Competency.query.filter_by(name=comp_name).first()
                    if not comp:
                        comp = Competency(name=comp_name)
                        db.session.add(comp)
                        db.session.flush()

                    job_comp = JobCompetency(
                        jobID=new_job.jobID,
                        competencyID=comp.id,
                        requiredRank=rank
                    )
                    db.session.add(job_comp)

            db.session.commit()
            print("Sample jobs created successfully!")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating sample jobs: {str(e)}")

@dashboard_views.route('/job-matches')
@login_required
def job_matches():
    if current_user.user_type != 'student':
        flash('Only students can view job matches.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
        
    try:
        create_sample_jobs()
        
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.dashboard'))
        
        job_matches = JobRole.get_matching_jobs(student)
        
        return render_template('Html/jobMatches.html', 
                             job_matches=job_matches,
                             user=student)
                             
    except Exception as e:
        print(f"Error loading job matches: {e}")
        import traceback
        traceback.print_exc()
        flash('Error loading job matches.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

@dashboard_views.route('/profile')
@login_required
def student_profile():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
        
    try:
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.dashboard'))
        
        # Get enrolled workshops
        enrolled_workshops = Workshop.query.join(Enrollment).filter(
            Enrollment.student_id == student.id
        ).all()
        
        # Get earned competencies
        earned_competencies = []
        if student.competencies:
            for comp_name, comp_data in student.competencies.items():
                rank = comp_data.get('rank', 0)
                certificate_status = comp_data.get('certificate_status', None)
                feedback = comp_data.get('feedback', '')
                
                if rank > 0:  
                    earned_competencies.append({
                        'name': comp_name,
                        'rank': rank,
                        'rank_name': ['Beginner', 'Intermediate', 'Advanced'][rank-1],
                        'certificate_status': certificate_status,
                        'feedback': feedback
                    })
        
        # Get job matches (limited to top 3)
        create_sample_jobs()
        job_matches = JobRole.get_matching_jobs(student)[:3]
        
        return render_template('Html/studentProfile.html', 
                             user=student,
                             earned_competencies=earned_competencies,
                             workshops=enrolled_workshops,
                             job_matches=job_matches)
                             
    except Exception as e:
        print(f"Error loading profile: {e}")
        import traceback
        traceback.print_exc()
        flash('Error loading profile.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))

@dashboard_views.route('/update-profile-pic', methods=['POST'])
@login_required
def update_profile_pic():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        if 'profile_pic' not in request.files:
            flash('No file part', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        file = request.files['profile_pic']
        if file.filename == '':
            flash('No selected file', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        if file and allowed_file(file.filename):
            # Create profile pics directory if it doesn't exist
            profile_pics_dir = 'App/static/profile_pics'
            if not os.path.exists(profile_pics_dir):
                os.makedirs(profile_pics_dir)
            
            # Generate unique filename
            filename = secure_filename(file.filename)
            # Add timestamp to prevent caching issues
            filename = f"{current_user.id}_{int(datetime.now().timestamp())}_{filename}"
            file_path = os.path.join(profile_pics_dir, filename)
            file.save(file_path)
            
            # Update student record
            student = Student.get_by_id(current_user.id)
            if student:
                # Delete old profile pic if exists
                if student.profile_pic:
                    old_pic_path = os.path.join(profile_pics_dir, student.profile_pic)
                    if os.path.exists(old_pic_path):
                        try:
                            os.remove(old_pic_path)
                        except:
                            pass
                
                # Update with new profile pic
                student.profile_pic = filename
                db.session.commit()
                flash('Profile picture updated successfully!', 'success')
            else:
                flash('Student record not found', 'error')
        else:
            flash('Invalid file type. Please upload an image file.', 'error')
    
    except Exception as e:
        print(f"Error updating profile picture: {e}")
        db.session.rollback()
        flash('An error occurred while updating profile picture.', 'error')
    
    return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/update-resume', methods=['POST'])
@login_required
def update_resume():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        if 'resume' not in request.files:
            flash('No file part', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        file = request.files['resume']
        if file.filename == '':
            flash('No selected file', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        # Create resumes directory if it doesn't exist
        resumes_dir = 'App/static/resumes'
        if not os.path.exists(resumes_dir):
            os.makedirs(resumes_dir)
        
        # Generate unique filename
        filename = secure_filename(file.filename)
        # Add timestamp to prevent caching issues
        filename = f"{current_user.id}_{int(datetime.now().timestamp())}_{filename}"
        file_path = os.path.join(resumes_dir, filename)
        file.save(file_path)
        
        # Update student record
        student = Student.get_by_id(current_user.id)
        if student:
            # Delete old resume if exists
            if student.resume:
                old_resume_path = os.path.join(resumes_dir, student.resume)
                if os.path.exists(old_resume_path):
                    try:
                        os.remove(old_resume_path)
                    except:
                        pass
            
            # Update with new resume
            student.resume = filename
            db.session.commit()
            flash('Resume updated successfully!', 'success')
        else:
            flash('Student record not found', 'error')
    
    except Exception as e:
        print(f"Error updating resume: {e}")
        db.session.rollback()
        flash('An error occurred while updating resume.', 'error')
    
    return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/download-resume')
@login_required
def download_resume():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        student = Student.get_by_id(current_user.id)
        if not student or not student.resume:
            flash('Resume not found', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        # Prepare resume file path
        resumes_dir = 'App/static/resumes'
        file_path = os.path.join(resumes_dir, student.resume)
        
        if not os.path.exists(file_path):
            flash('Resume file not found', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        # Extract original filename from stored filename
        original_filename = student.resume.split('_', 2)[2] if len(student.resume.split('_', 2)) > 2 else student.resume
        
        # Return file for download
        return send_from_directory(
            os.path.abspath(resumes_dir),
            student.resume,
            as_attachment=True,
            download_name=original_filename
        )
    
    except Exception as e:
        print(f"Error downloading resume: {e}")
        flash('An error occurred while downloading resume.', 'error')
        return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/remove-resume')
@login_required
def remove_resume():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        student = Student.get_by_id(current_user.id)
        if not student or not student.resume:
            flash('No resume to remove', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        # Get resume file path
        resumes_dir = 'App/static/resumes'
        file_path = os.path.join(resumes_dir, student.resume)
        
        # Delete the file if it exists
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                print(f"Deleted resume file: {file_path}")
            except Exception as file_error:
                print(f"Error deleting resume file: {file_error}")
        
        # Update the student record
        student.resume = None
        db.session.commit()
        flash('Resume removed successfully', 'success')
        
    except Exception as e:
        print(f"Error removing resume: {e}")
        db.session.rollback()
        flash('An error occurred while removing the resume', 'error')
    
    return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/generate-resume')
@login_required
def generate_resume():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        earned_competencies = []
        if student.competencies:
            for comp_name, comp_data in student.competencies.items():
                rank = comp_data.get('rank', 0)
                certificate_status = comp_data.get('certificate_status', None)
                
                if rank > 0:  
                    earned_competencies.append({
                        'name': comp_name,
                        'rank': rank,
                        'rank_name': ['Beginner', 'Intermediate', 'Advanced'][rank-1],
                        'certificate_status': certificate_status
                    })
        
        enrolled_workshops = Workshop.query.join(Enrollment).filter(
            Enrollment.student_id == student.id
        ).all()
        
        resumes_dir = 'App/static/resumes'
        if not os.path.exists(resumes_dir):
            os.makedirs(resumes_dir)
        
        timestamp = int(datetime.now().timestamp())
        filename = f"{student.id}_{timestamp}_generated_resume.pdf"
        file_path = os.path.join(resumes_dir, filename)
        
        try:
            doc = SimpleDocTemplate(
                file_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            styles = getSampleStyleSheet()
            title_style = styles['Heading1']
            heading_style = styles['Heading2']
            normal_style = styles['Normal']
            
            competency_style = ParagraphStyle(
                'CompetencyStyle',
                parent=styles['Normal'],
                spaceAfter=6,
                bulletIndent=0,
                leftIndent=0
            )
            
            story = []
            
            # Header
            story.append(Paragraph(f"{student.first_name} {student.last_name}", title_style))
            contact_info = f"{student.email}"
            if student.phone:
                contact_info += f" | {student.phone}"
            if student.location:
                contact_info += f" | {student.location}"
            story.append(Paragraph(contact_info, normal_style))
            story.append(Spacer(1, 12))
            
            # Summary
            story.append(Paragraph("SUMMARY", heading_style))
            story.append(Paragraph(
                "A highly skilled individual with a diverse set of competencies and certifications from the UWI Career Competency Tracking System. "
                "Experienced in multiple areas with a focus on continuous professional development.",
                normal_style
            ))
            story.append(Spacer(1, 12))
            
            # Competencies
            story.append(Paragraph("COMPETENCIES", heading_style))
            if earned_competencies:
                for comp in earned_competencies:
                    comp_text = f"<b>{comp['name']}</b>"
                    if comp.get('certificate_status') == 'approved':
                        comp_text += " (Certified)"
                    comp_text += f"<br/>Level: {comp['rank_name']}<br/>"
                    
                    if comp['rank'] == 1:
                        desc = f"Basic knowledge and understanding of {comp['name']} concepts."
                    elif comp['rank'] == 2:
                        desc = f"Practical application and intermediate knowledge of {comp['name']}."
                    else:
                        desc = f"Advanced expertise and comprehensive knowledge of {comp['name']} with demonstrated proficiency."
                    
                    comp_text += desc
                    story.append(Paragraph(comp_text, competency_style))
                    story.append(Spacer(1, 6))
            else:
                story.append(Paragraph("No competencies listed.", normal_style))
            
            story.append(Spacer(1, 12))
            
            # Workshops
            story.append(Paragraph("WORKSHOPS & TRAINING", heading_style))
            if enrolled_workshops:
                for workshop in enrolled_workshops:
                    workshop_text = f"<b>{workshop.workshopName}</b><br/>"
                    workshop_text += f"Date: {workshop.workshopDate.strftime('%B %d, %Y')} | "
                    workshop_text += f"Instructor: {workshop.instructor} | "
                    workshop_text += f"Location: {workshop.location}<br/>"
                    
                    if workshop.workshopDescription:
                        workshop_text += workshop.workshopDescription
                    
                    story.append(Paragraph(workshop_text, competency_style))
                    story.append(Spacer(1, 6))
            else:
                story.append(Paragraph("No workshops or training listed.", normal_style))
            
            story.append(Spacer(1, 12))
            
            # Education
            story.append(Paragraph("EDUCATION", heading_style))
            education_text = "<b>University of the West Indies</b><br/>"
            education_text += f"Degree Program: {student.degree or '[Student\'s Degree]'}<br/>"
            education_text += "Participated in the UWI Career Competency Tracking System to develop and validate professional skills."
            story.append(Paragraph(education_text, competency_style))
            
            story.append(Spacer(1, 12))
            
            # Additional Information
            story.append(Paragraph("ADDITIONAL INFORMATION", heading_style))
            story.append(Paragraph(
                "This resume was automatically generated based on verified competencies and completed workshops "
                "tracked through the UWI Career Competency Tracking System. All listed competencies have been "
                "validated by instructors and administrators.",
                normal_style
            ))
            
            # Build the PDF
            doc.build(story)
            
            # Update student record with generated resume
            student.resume = filename
            db.session.commit()
            flash('Resume generated successfully!', 'success')
            
            # Redirect to download the generated resume
            return redirect(url_for('dashboard_views.download_resume'))
            
        except Exception as pdf_error:
            print(f"Error generating PDF: {pdf_error}")
            import traceback
            traceback.print_exc()
            flash('Error generating PDF resume.', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
    except Exception as e:
        print(f"Error generating resume: {e}")
        import traceback
        traceback.print_exc()
        flash('An error occurred while generating resume.', 'error')
        return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/merge-resume')
@login_required
def merge_resume():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        student = Student.get_by_id(current_user.id)
        if not student:
            flash('Student account not found.', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        if not student.resume:
            flash('You need to upload a resume first before adding competencies to it.', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        # Get earned competencies
        earned_competencies = []
        if student.competencies:
            for comp_name, comp_data in student.competencies.items():
                rank = comp_data.get('rank', 0)
                certificate_status = comp_data.get('certificate_status', None)
                
                if rank > 0:  
                    earned_competencies.append({
                        'name': comp_name,
                        'rank': rank,
                        'rank_name': ['Beginner', 'Intermediate', 'Advanced'][rank-1],
                        'certificate_status': certificate_status
                    })
        
        if not earned_competencies:
            flash('You do not have any competencies to add to your resume.', 'info')
            return redirect(url_for('dashboard_views.student_profile'))
            
        # Get enrolled workshops
        enrolled_workshops = Workshop.query.join(Enrollment).filter(
            Enrollment.student_id == student.id
        ).all()
        
        # Resumes directory
        resumes_dir = 'App/static/resumes'
        
        # Get existing resume path
        existing_resume_path = os.path.join(resumes_dir, student.resume)
        
        if not os.path.exists(existing_resume_path):
            flash('Existing resume file not found', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
        # Generate unique filename for competency PDF and merged resume
        timestamp = int(datetime.now().timestamp())
        merged_filename = f"{student.id}_{timestamp}_enhanced_resume.pdf"
        competency_pdf_path = os.path.join(resumes_dir, f"temp_competency_{timestamp}.pdf")
        merged_file_path = os.path.join(resumes_dir, merged_filename)
        
        try:
            # 1. Generate PDF of just the competencies using ReportLab
            doc = SimpleDocTemplate(
                competency_pdf_path,
                pagesize=letter,
                rightMargin=72,
                leftMargin=72,
                topMargin=72,
                bottomMargin=72
            )
            
            # Define styles
            styles = getSampleStyleSheet()
            title_style = styles['Heading1']
            heading_style = styles['Heading2']
            normal_style = styles['Normal']
            
            # Custom styles
            competency_style = ParagraphStyle(
                'CompetencyStyle',
                parent=styles['Normal'],
                spaceAfter=6,
                bulletIndent=0,
                leftIndent=0
            )
            
            # Build PDF content
            story = []
            
            # Title
            story.append(Paragraph("COMPETENCY PROFILE", title_style))
            story.append(Paragraph(f"For {student.first_name} {student.last_name}", normal_style))
            story.append(Spacer(1, 12))
            
            # Competencies
            story.append(Paragraph("VERIFIED COMPETENCIES", heading_style))
            if earned_competencies:
                for comp in earned_competencies:
                    comp_text = f"<b>{comp['name']}</b>"
                    if comp.get('certificate_status') == 'approved':
                        comp_text += " (Certified)"
                    comp_text += f"<br/>Level: {comp['rank_name']}<br/>"
                    
                    if comp['rank'] == 1:
                        desc = f"Basic knowledge and understanding of {comp['name']} concepts."
                    elif comp['rank'] == 2:
                        desc = f"Practical application and intermediate knowledge of {comp['name']}."
                    else:
                        desc = f"Advanced expertise and comprehensive knowledge of {comp['name']} with demonstrated proficiency."
                    
                    comp_text += desc
                    story.append(Paragraph(comp_text, competency_style))
                    story.append(Spacer(1, 6))
            else:
                story.append(Paragraph("No competencies listed.", normal_style))
            
            story.append(Spacer(1, 12))
            
            # Workshops
            story.append(Paragraph("WORKSHOPS & TRAINING", heading_style))
            if enrolled_workshops:
                for workshop in enrolled_workshops:
                    workshop_text = f"<b>{workshop.workshopName}</b><br/>"
                    workshop_text += f"Date: {workshop.workshopDate.strftime('%B %d, %Y')} | "
                    workshop_text += f"Instructor: {workshop.instructor} | "
                    workshop_text += f"Location: {workshop.location}<br/>"
                    
                    if workshop.workshopDescription:
                        workshop_text += workshop.workshopDescription
                    
                    story.append(Paragraph(workshop_text, competency_style))
                    story.append(Spacer(1, 6))
            else:
                story.append(Paragraph("No workshops or training listed.", normal_style))
            
            story.append(Spacer(1, 12))
            
            # Certification
            story.append(Paragraph("CERTIFICATION", heading_style))
            story.append(Paragraph(
                "The above competencies have been verified by the UWI Career Competency Tracking System. "
                "This system tracks and validates skills acquired through formal workshops and training sessions.",
                normal_style
            ))
            
            # Build the PDF
            doc.build(story)
            
            # 2. Merge PDFs using PyPDF2
            with open(existing_resume_path, 'rb') as file_original:
                original_pdf = PdfReader(file_original)
                
                with open(competency_pdf_path, 'rb') as file_competency:
                    competency_pdf = PdfReader(file_competency)
                    
                    # Create a PDF writer
                    merger = PdfWriter()
                    
                    # Add all pages from both PDFs
                    for page in original_pdf.pages:
                        merger.add_page(page)
                    
                    for page in competency_pdf.pages:
                        merger.add_page(page)
                    
                    # Write the merged PDF to file
                    with open(merged_file_path, 'wb') as output_file:
                        merger.write(output_file)
            
            # Remove temporary competency PDF
            if os.path.exists(competency_pdf_path):
                os.remove(competency_pdf_path)
            
            # Save old resume path to delete it later
            old_resume_path = os.path.join(resumes_dir, student.resume)
            
            # Update student record with merged resume
            student.resume = merged_filename
            db.session.commit()
            
            # Delete old resume file if different from the new one
            if os.path.exists(old_resume_path) and old_resume_path != merged_file_path:
                try:
                    os.remove(old_resume_path)
                except Exception as file_error:
                    print(f"Warning: Could not delete old resume: {file_error}")
            
            flash('Your resume has been enhanced with your competencies and skills!', 'success')
            
            # Redirect to download the merged resume
            return redirect(url_for('dashboard_views.download_resume'))
            
        except Exception as pdf_error:
            print(f"Error merging PDF: {pdf_error}")
            import traceback
            traceback.print_exc()
            flash('Error adding competencies to your resume.', 'error')
            return redirect(url_for('dashboard_views.student_profile'))
        
    except Exception as e:
        print(f"Error merging resume: {e}")
        import traceback
        traceback.print_exc()
        flash('An error occurred while enhancing your resume.', 'error')
        return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/update-personal-info', methods=['POST'])
@login_required
def update_personal_info():
    if current_user.user_type != 'student':
        flash('Access denied. Students only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        phone = request.form.get('phone', '')
        location = request.form.get('location', '')
        degree = request.form.get('degree', '')
        
        student = Student.get_by_id(current_user.id)
        if student:
            student.phone = phone
            student.location = location
            student.degree = degree
            db.session.commit()
            flash('Personal information updated successfully!', 'success')
        else:
            flash('Student record not found', 'error')
            
    except Exception as e:
        print(f"Error updating personal information: {e}")
        db.session.rollback()
        flash('An error occurred while updating personal information.', 'error')
    
    return redirect(url_for('dashboard_views.student_profile'))

@dashboard_views.route('/view-candidate-profile/<int:student_id>')
@login_required
def view_candidate_profile(student_id):
    if current_user.user_type != 'employer':
        flash('Access denied. Employers only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        student = Student.query.get_or_404(student_id)
        
        # Get enrolled workshops
        enrolled_workshops = Workshop.query.join(Enrollment).filter(
            Enrollment.student_id == student.id
        ).all()
        
        # Get earned competencies
        earned_competencies = []
        if student.competencies:
            for comp_name, comp_data in student.competencies.items():
                rank = comp_data.get('rank', 0)
                certificate_status = comp_data.get('certificate_status', None)
                feedback = comp_data.get('feedback', '')
                
                if rank > 0:  
                    earned_competencies.append({
                        'name': comp_name,
                        'rank': rank,
                        'rank_name': ['Beginner', 'Intermediate', 'Advanced'][rank-1],
                        'certificate_status': certificate_status,
                        'feedback': feedback
                    })
        
        return render_template('Html/viewCandidateProfile.html', 
                              student=student,
                              earned_competencies=earned_competencies,
                              workshops=enrolled_workshops,
                              user=current_user)
                              
    except Exception as e:
        print(f"Error loading candidate profile: {e}")
        import traceback
        traceback.print_exc()
        flash('Error loading candidate profile.', 'error')
        return redirect(url_for('dashboard_views.search_candidates'))

@dashboard_views.route('/view-candidate-resume/<int:student_id>')
@login_required
def view_candidate_resume(student_id):
    if current_user.user_type != 'employer':
        flash('Access denied. Employers only.', 'error')
        return redirect(url_for('dashboard_views.dashboard'))
    
    try:
        student = Student.query.get_or_404(student_id)
        if not student or not student.resume:
            flash('Resume not found', 'error')
            return redirect(url_for('dashboard_views.view_candidate_profile', student_id=student_id))
        
        # Prepare resume file path
        resumes_dir = 'App/static/resumes'
        file_path = os.path.join(resumes_dir, student.resume)
        
        if not os.path.exists(file_path):
            flash('Resume file not found', 'error')
            return redirect(url_for('dashboard_views.view_candidate_profile', student_id=student_id))
        
        # Extract original filename from stored filename
        original_filename = student.resume.split('_', 2)[2] if len(student.resume.split('_', 2)) > 2 else student.resume
        
        # Return file for viewing
        return send_from_directory(
            os.path.abspath(resumes_dir),
            student.resume,
            as_attachment=False,
            download_name=original_filename
        )
    
    except Exception as e:
        print(f"Error viewing candidate resume: {e}")
        flash('An error occurred while viewing resume.', 'error')
        return redirect(url_for('dashboard_views.view_candidate_profile', student_id=student_id))

@dashboard_views.route('/get-notifications')
@login_required
def get_notifications():
    """
    Get notifications for the current user (API endpoint)
    """
    if current_user.user_type != 'student':
        return jsonify({'error': 'Access denied. Students only.'}), 403
    
    limit = request.args.get('limit', 10, type=int)
    unread_only = request.args.get('unread_only', False, type=bool)
    
    notifications = notification_controller.get_notifications(
        student_id=current_user.id,
        limit=limit,
        unread_only=unread_only
    )
    
    unread_count = notification_controller.get_unread_count(current_user.id)
    
    return jsonify({
        'notifications': [
            {
                'id': n.id,
                'message': n.message,
                'notification_type': n.notification_type,
                'created_at': n.created_at.strftime('%Y-%m-%d %H:%M:%S'),
                'is_read': n.is_read,
                'link': n.link
            } for n in notifications
        ],
        'unread_count': unread_count
    })

@dashboard_views.route('/mark-notification-read/<int:notification_id>', methods=['POST'])
@login_required
def mark_notification_read(notification_id):
    """
    Mark a notification as read
    """
    if current_user.user_type != 'student':
        return jsonify({'error': 'Access denied. Students only.'}), 403
    
    # Ensure the notification belongs to the current user
    notification = Notification.query.get(notification_id)
    if not notification or notification.student_id != current_user.id:
        return jsonify({'error': 'Notification not found or unauthorized.'}), 404
    
    success = notification_controller.mark_as_read(notification_id)
    
    if success:
        return jsonify({'success': True})
    else:
        return jsonify({'error': 'Error marking notification as read.'}), 500

@dashboard_views.route('/mark-all-notifications-read', methods=['POST'])
@login_required
def mark_all_notifications_read():
    """
    Mark all notifications as read for the current user
    """
    if current_user.user_type != 'student':
        return jsonify({'error': 'Access denied. Students only.'}), 403
    
    count = notification_controller.mark_all_as_read(current_user.id)
    
    return jsonify({
        'success': True,
        'count': count
    })

@dashboard_views.route('/test-notification/<int:student_id>/<notification_type>')
def test_notification(student_id, notification_type):
    """
    Test notification creation
    """
    try:
        # Check if student exists
        student = Student.query.get(student_id)
        if not student:
            return jsonify({'error': f'Student with ID {student_id} not found'}), 404
        
        # Create different types of notifications based on the notification_type
        if notification_type == 'workshop':
            notification = notification_controller.create_workshop_notification(
                student_id, 
                workshop_name="Test Workshop", 
                action_type="created", 
                link="/my-workshops"
            )
            return jsonify({'success': True, 'message': f'Created workshop notification for student {student_id}'})
            
        elif notification_type == 'badge':
            notification = notification_controller.create_badge_notification(
                student_id, 
                competency_name="Test Competency", 
                rank=2, 
                link="/earned-badges"
            )
            return jsonify({'success': True, 'message': f'Created badge notification for student {student_id}'})
            
        elif notification_type == 'certificate':
            notification = notification_controller.create_certificate_notification(
                student_id, 
                competency_name="Test Competency", 
                status="approved", 
                link="/earned-badges"
            )
            return jsonify({'success': True, 'message': f'Created certificate notification for student {student_id}'})
            
        else:
            # Create a generic notification
            notification = notification_controller.create_notification(
                student_id=student_id,
                message=f"This is a test {notification_type} notification",
                notification_type="general",
                link="/student-dashboard"
            )
            return jsonify({'success': True, 'message': f'Created generic notification for student {student_id}'})
            
    except Exception as e:
        return jsonify({'error': f'Error creating notification: {str(e)}'}), 500

def init_dashboard_routes(app):
    app.register_blueprint(dashboard_views) 